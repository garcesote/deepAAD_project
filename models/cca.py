from tqdm import tqdm
import numpy as np
import torch
from sklearn.cross_decomposition import CCA
from sklearn.discriminant_analysis import LinearDiscriminantAnalysis
from scipy.stats import pearsonr

class CCA_AAD: 

    """ Canonical Correlation Analysis

    This class defines the method for performing the CCA in an auditory attention decoding (AAD) scenario.
    
    It includes the proper CCA part in which the model projects the stim and the EEG into a sub-space
    of n_components in which the irrelevant varance is minimized from both sets.

    A linear discriminant analysis is also computed in order to classify the correlation scores obtained
    on the projected space.

    For both steps the scikitlearn package functions cross_decomposition.CCA and discriminant_analysis.
    LinearDiscriminantAnalysis are used.

    As a firt step when data is introduced this class computes the lagged matrices for both stim and eeg.

    Args:

        encoder_len: defines the number of pre-stim for computing the lagged stim matrix

        decoder_len: defines the number of post-stim samples for computing the eeg stim matrix

        n_components: defines the dimensions of the projected subspace (by default: min(encoder_len, decoder_len))

    """
    def __init__(self, encoder_len:int, decoder_len:int, n_components:int = None, max_iter:int = 500, tol:float = 1e-06):
        
        self.encoder_len = encoder_len
        self.decoder_len = decoder_len
        self.n_components = n_components if n_components is not None else min(encoder_len, decoder_len)

        self.model = CCA(n_components=n_components, max_iter=max_iter, tol=tol, copy=False)
        self.classf = None
        self.best_accuracy = None

    def fit_CCA(self, eeg, stim):

        """ Fit the model to the data

        Firstly the lagged matrix is computed for both sets and then the CCA gets fitted

        Args:

            eeg: array-like or tensor EEG signal (n_channels, n_samples)

            stim: array-like or tensor envelope (n_chan, n_samples)
        
        """
        
        # Generate lag matrices
        lagged_eeg = self._get_lagged_matrix(eeg, pre_stim = False)
        lagged_stim = self._get_lagged_matrix(stim, pre_stim = True)

        # Guarda las matrices en disco temporalmente
        eeg_memmap = np.memmap('temp_eeg.dat', dtype=np.float32, mode='w+', shape=lagged_eeg.shape)
        eeg_memmap[:] = lagged_eeg[:]

        stim_memmap = np.memmap('temp_stim.dat', dtype=np.float32, mode='w+', shape=lagged_stim.shape)
        stim_memmap[:] = lagged_stim[:]

        # Trabaja con los memmaps
        self.model.fit(eeg_memmap.T, stim_memmap.T)

    def transform(self, eeg, stim):

        """ Projects the introduced data into the CCA subspace: fit_CCA before!!
        
        Args:

            eeg: array-like or tensor EEG signal (n_channels, n_samples)

            stim: array-like or tensor attended envelope (n_samples, )

        """

        lagged_eeg = self._get_lagged_matrix(eeg, pre_stim=False)
        lagged_stim = self._get_lagged_matrix(stim, pre_stim=True)
    
        eeg_proj, stim_proj  = self.model.transform(lagged_eeg.T, lagged_stim.T)

        return eeg_proj.T, stim_proj.T
    
    def score(self, eeg, stim):

        """ Compute the correlation on the projected subspace between eeg and stim
        
        Args:

            eeg (array-like or tensor): EEG signal of shape (n_channels, n_samples)

            stim (array-like or tensor): envelope of shape (n_samples, )

        Returns:

            score (array-like): pearson correlation coefficients of shape (n_components)

        """

        # Obtain the projected vectors
        eeg_proj, stim_proj = self.transform(eeg, stim)

        score = np.array([pearsonr(eeg_proj[j], stim_proj[j])[0] for j in range(self.n_components)])

        return score
    
    def score_in_batches(self, eeg, stim, batch_size):

        """ Compute the correlation on the projected subspace between eeg and stim in different batches
        
        Args:

            eeg (array-like or tensor): EEG signal of shape (n_channels, n_samples)

            stim (array-like or tensor): envelope of shape (n_samples, )

            batch_size (int): lenght of the windowed data

        Returns:

            scores (array-like): pearson correlation coefficients of shape (n_batch, n_components)

        """

        n_chan, n_times = eeg.shape
        n_batch = n_times // batch_size
        scores = np.zeros((n_batch, self.n_components))

        # Generate the scores generated by the CCA coefficients
        for n in range(n_batch):
            
            # Compute the lagged matrix
            eeg_win = eeg[:, n*batch_size:(n+1)*batch_size]
            stim_win = stim[:, n*batch_size:(n+1)*batch_size]

            # Obtain the projected vectors
            eeg_proj, stim_proj = self.transform(eeg_win, stim_win)

            scores[n, :] = np.array([pearsonr(eeg_proj[j], stim_proj[j])[0] for j in range(self.n_components)])

        return scores
            
    def fit_LDA(self, eeg, stima, stimb, eeg_val, stima_val, stimb_val, batch_size):

        """ Fit the classifier model using the CCA coefficients
        
        Args:

            eeg (array-like or tensor): EEG signal of shape (n_channels, n_samples)

            stima (array-like or tensor): attended envelope of shape (n_samples, )

            stimb (array-like or tensor): unattended envelope of shape (n_samples, )

            _val: included to select the best number of components

            batch_size (int): lenght of the windowed data

        """

        # Get the scores
        scores_a = self.score_in_batches(eeg, stima, batch_size)
        scores_b = self.score_in_batches(eeg, stimb, batch_size)

        # Get the scores
        scores_a_val = self.score_in_batches(eeg_val, stima_val, batch_size)
        scores_b_val = self.score_in_batches(eeg_val, stimb_val, batch_size)

        # Difference between scores as the function to classify
        # f_att = scores_a - scores_b
        # f_unatt = scores_b - scores_a

        accuracies = []
        best_accuracy = 0
        best_n_components = 0
        for n in range(self.n_components):

            f_att = scores_a[:, :n+1]
            f_unatt = scores_b[:, :n+1]

            # Concatenate the scores and generate a label array to feed LDA
            scores = np.vstack((f_att, f_unatt))
            labels = np.concatenate((np.ones(f_att.shape[0]), np.zeros(f_unatt.shape[0])))

            # Load and fit a classifier with training data
            classifier = LinearDiscriminantAnalysis()
            classifier.fit(scores, labels)

            # Get accuracy for validation set
            att_correct = 0
            f_att = scores_a_val[:, :n+1]
            f_unatt = scores_b_val[:, :n+1]
            # Transform into a 1D space with LDA
            f_att = classifier.transform(f_att)
            f_unatt = classifier.transform(f_unatt)
            for att, unatt in zip(f_att, f_unatt):
                if att > unatt: 
                    att_correct +=1
            # Compute the accuracy
            accuracy = (att_correct / len(f_att)) * 100
            accuracies.append(accuracy)

            # Save the best classifier
            if accuracy > best_accuracy:
                self.classf = classifier
                best_accuracy = accuracy
                best_n_components = n+1

        # Set the n_components that achieved the best results
        self.n_components = best_n_components
        self.best_accuracy = best_accuracy


    def classify_in_batches(self, eeg, stima, stimb, batch_size):

        """ Estimate the scores using the canonical vectors and classify with LDA
        
        Args:

            eeg (array-like or tensor): EEG signal of shape (n_channels, n_samples)

            stima (array-like or tensor): attended envelope of shape (n_samples, )

            stimb (array-like or tensor): unattended envelope of shape (n_samples, )

            batch_size (int): lenght of the windowed data

        Returns

            accuracy (float): % of correct classified batches of data

        """

        # Get the scores
        scores_a = self.score_in_batches(eeg, stima, batch_size)
        scores_b = self.score_in_batches(eeg, stimb, batch_size)

        # Difference between scores as the function to classify
        # f_att = scores_a - scores_b
        # f_unatt = scores_b - scores_a
        f_att = scores_a
        f_unatt = scores_b

        att_correct = 0
        # Transorm into a 1D space with LDA
        f_att = self.classf.transform(f_att)
        f_unatt = self.classf.transform(f_unatt)
        for att, unatt in zip(f_att, f_unatt):
            if att > unatt: att_correct +=1
        
        return (att_correct / len(f_att)) * 100
    
    # Lagged function: Introduce a matrix of shape (C, T) and return a matrix (L*C, T)
    def _get_lagged_matrix(self, X, pre_stim: bool= True):
        
        if pre_stim:
            start_lag, end_lag  = 0, self.encoder_len
        else:
            start_lag, end_lag  = -self.decoder_len, 0

        n_chan, n_times = X.shape
        num_lags = end_lag - start_lag
        lagged_matrix = np.zeros((n_chan * num_lags, n_times))

        if start_lag < 0:
            range = np.arange(end_lag, start_lag, -1)
        else:
            range = np.arange(start_lag, end_lag)

        for i, lag in enumerate(range):
            
            shifted_X = np.roll(X, shift=lag, axis=1)

            # Rellenamos los elementos desplazados con ceros según el signo de lag
            if lag > 0:
                shifted_X[:, :lag] = 0  # Zerofill beginning if lag > 0
            elif lag < 0:
                shifted_X[:, lag:] = 0  # Zerofill end if lag < 0

            # Insertamos el canal desplazado en su posición en la matriz lageada
            lagged_matrix[i * n_chan:(i + 1) * n_chan, :] = shifted_X

        return lagged_matrix